var e=class e{static base64ToBytes(e){const t=atob(e);return Uint8Array.from(t,(e=>e.charCodeAt(0)))}static bytesToBase64(e){const t=String.fromCodePoint(...e);return btoa(t)}static isWellFormed(e){if("function"==typeof e.isWellFormed)return e.isWellFormed();try{return encodeURIComponent(e),!0}catch(e){return!1}}static encoder(t){if(e.isWellFormed(t))return e.bytesToBase64((new TextEncoder).encode(t));console.warn(`Stringa non valida: [${t}]`)}static decoder(t){if(e.isWellFormed(t))return(new TextDecoder).decode(e.base64ToBytes(t));console.warn(`Stringa Base64 non valida: [${t}]`)}static async fileIn64(e){const t=await e.arrayBuffer();return btoa(String.fromCharCode(...new Uint8Array(t)))}static toUnicode(e){return e.split("").map((e=>`\\u${e.charCodeAt(0).toString(16).padStart(4,"0")}`)).join("")}static fromUnicode(e){return e.replace(/\\u([0-9a-fA-F]{4})/g,((e,t)=>String.fromCharCode(parseInt(t,16))))}},t=class{static iterativeValuesFromKeysExtractor=(e,t)=>{if("object"!=typeof e||null===e||!Array.isArray(t))return{};const r=[e],o={};for(t.forEach((e=>o[e]=[]));r.length;){const e=r.pop();if("object"==typeof e&&null!==e){for(const r of t)r in e&&o[r].push(e[r]);for(const t of Object.values(e))"object"==typeof t&&null!==t&&r.push(t)}}return o}};export{e as XMorpher,t as XSeeker,e as XirGlyphMorpher,t as XirSeekerClass};